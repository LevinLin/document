1.install go env on Mac

> brew install go
> vi /Users/levin.lin/.bash_profile
  # for golang
  export PATH="/usr/local/Cellar/go/1.4.2/bin:$PATH"
  export GOPATH="$HOME/GoRoot/go"
  export GOROOT="/usr/local/Cellar/go/1.4.2/libexec"
  export GOBIN="$GOPATH/bin"
  export PATH="$GOBIN:$PATH"
> go env
  GOARCH="amd64"
  GOBIN="/Users/levin.lin/GoRoot/go/bin"
  GOCHAR="6"
  GOEXE=""
  GOHOSTARCH="amd64"
  GOHOSTOS="darwin"
  GOOS="darwin"
  GOPATH="/Users/levin.lin/GoRoot/go"
  GORACE=""
  GOROOT="/usr/local/Cellar/go/1.4.2/libexec"
  GOTOOLDIR="/usr/local/Cellar/go/1.4.2/libexec/pkg/tool/darwin_amd64"
  CC="clang"
  GOGCCFLAGS="-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common"
  CXX="clang++"
  CGO_ENABLED="1"

2.goroutine
> 在Go語言中，每一個併髮的執行單元叫作一個goroutine
> 當一個程序啓動時，其主函數卽在一個單獨的goroutine中運行，我們叫它main goroutine。新的goroutine會用go語句來創建。在語法上，go語句是一個普通的函數或方法調用前加上關鍵字go。go語句會使其語句中的函數在一個新創建的goroutine中運行。而go語句本身會迅速地完成。
  f()    // call f(); wait for it to return
  go f() // create a new goroutine that calls f(); don't wait
> 當主函數返迴時，所有的goroutine都會直接打斷，程序退齣。除了從主函數退齣或者直接退齣程序之外，沒有其它的編程方法能夠讓一個goroutine來打斷另一個的執行，可以通過goroutine之間的通信來讓一個goroutine請求請求其它的goroutine，併讓其自己結束執行。
> goroutine和綫程的本質區彆
  A goroutine is a lightweight thread of execution
  
3.channel
> Channels are the pipes that connect concurrent goroutines. You can send values into channels from one goroutine and receive those values into another goroutine.
> Create a new channel with make(chan val-type). Channels are typed by the values they convey.
> Send a value into a channel using the `[channel] <-` syntax
> The `<-[channel]` syntax receives a value from the channel. 
> By default sends and receives block until both the sender and receiver are ready. 

  package main
  import "fmt"
  func main() {
      messages := make(chan string)
      go func() { messages <- "ping" }()
      msg := <-messages
      fmt.Println(msg)
  }
  
  $ go run channels.go 
  ping

4.select
> Go’s select lets you wait on multiple channel operations. 
  package main
  import "time"
  import "fmt"
  func main() {
      c1 := make(chan string)
      c2 := make(chan string)
      go func() {
        time.Sleep(time.Second * 1)
        c1 <- "one"
      }()
      go func() {
        time.Sleep(time.Second * 2)
        c2 <- "two"
      }()
      for i := 0; i < 2; i++ {
          select {
              case msg1 := <-c1:
                  fmt.Println("received", msg1)
              case msg2 := <-c2:
                  fmt.Println("received", msg2)
          }
      }
  }

5.timeout
> Implementing timeouts in Go is easy and elegant thanks to channels and select.
  Here’s the select implementing a timeout. res := <-c1 awaits the result and <-Time.After awaits a value to be sent after the timeout of 1s. Since select proceeds with the first receive that’s ready, we’ll take the timeout case if the operation takes more than the allowed 1s.
  
  package main
  import "time"
  import "fmt"
  func main() {
      c1 := make(chan string, 1)
      go func() {
          time.Sleep(time.Second * 2)
          c1 <- "result 1"
      }()
      select { //2>1,timout!
          case res := <-c1:
              fmt.Println(res)
          case <-time.After(time.Second * 1):
              fmt.Println("timeout 1")
      }
      c2 := make(chan string, 1)
      go func() {
          time.Sleep(time.Second * 2)
          c2 <- "result 2"
      }()
      select { // 2<3, no timeout
          case res := <-c2:
              fmt.Println(res)
          case <-time.After(time.Second * 3):
              fmt.Println("timeout 2")
      }
  }
  
6.
