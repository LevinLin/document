1.jQuery.makeArray( obj )
  Description: 
  > Convert an array-like object into a true JavaScript array.
  > [obj] Type: PlainObject - Any object to turn into a native Array.
  > Many methods, both in jQuery and in JavaScript in general, return objects that are array-like. For example, the jQuery factory function $() returns a jQuery object that has many of the properties of an array (a length, the [] array access operator, etc.), but is not exactly the same as an array and lacks some of an array's built-in methods (such as .pop() and .reverse()).
    Note that after the conversion, any special features the object had (such as the jQuery methods in our example) will no longer be present. The object is now a plain array.
  > [example]
    var obj = eval('(' + json + ')');
    var array = $.makeArray(obj.xxx);
    
2.jQuery.inArray( value, array [, fromIndex ] )
  > Description: Search for a specified value within an array and return its index (or -1 if not found).
  > [fromIndex] Type: Number - The index of the array at which to begin the search. The default is 0, which will search the whole array.
  > 如果数组第一个元素匹配value，$.inArray()返回0。因为JavaScript将0视为false(即 0 == false, 但是 0 !== false)，如果我们检查在array中存在value，我们只需要检查它是否不等于（或大于）-1
  > [example]
    $("input:checkbox[name='xxx']").each(function(){
        if (jQuery.inArray($(this).val(), array) > -1) {
            $(this).prop('checked', true);
        };
    });
    
3.jquery set checkbox checked
  > .prop( propertyName, value )
  > Description: Set one or more properties for the set of matched elements.
  > The .prop() method is a convenient way to set the value of properties—especially when setting multiple properties, using values returned by a function, or setting values on multiple elements at once. It should be used when setting selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, or defaultSelected. Since jQuery 1.6, these properties can no longer be set with the .attr() method. They do not have corresponding attributes and are only properties.
  > Properties generally affect the dynamic state of a DOM element without changing the serialized HTML attribute. Examples include the value property of input elements, the disabled property of inputs and buttons, or the checked property of a checkbox. The .prop() method should be used to set disabled and checked instead of the .attr() method. The .val() method should be used for getting and setting value.
  > [example 1]
    $( "input" ).prop( "disabled", false );
    $( "input" ).prop( "checked", true );
    $( "input" ).val( "someValue" );
  > [example 2]
    $("input:checkbox[name='xxx']").each(function(){
        if (jQuery.inArray($(this).val(), array) > -1) {
            $(this).prop('checked', true);
        };
    });
   
4.dataTable.draw() vs. dataTable.destroy()(/destroy option)
  > [background infomation]
    1.there is a page consist of several filters and table for filtered result
    2.we need to get result based on filters and then generate the table
  > [solutions]
    (1) simplely use dataTable( option )
      var dataTable;
      $('#filterButton').on( 'click', function() {
        dataTable = $('#example').dataTable( {
          ...
          "ajax": {
            "url": "...",
            "type": "GET",
            "cache": false,
            "data": {         //refresh fiters while redraw table
              filter1:$('#filter1').val(),
              filter2:$('#filter2').val(),
              filter3:$('#filter3').val(),
              ...
            }
          },
        } );
      } );
      
      [problem] Warning: Cannot reinitialise DataTable
      [reason] DataTables has a wide range of configuration options which can be used to customise the table at initialisation time, 
      but only at initialisation time. After a DataTable has been initialised any attempt to use these options will result in an error.
   
    (2) use draw() to workaround the error depending on whether dataTable has been initialised or not
      var dataTable = null;
      $('#filterButton').on( 'click', function() {
        if( null != dataTable) {
          dataTable.draw( false );
        } else {
          dataTable = $('#example').dataTable( {
            ...
            "ajax": {
              "url": "...",
              "type": "GET",
              "cache": false,
              "data": {         //refresh fiters while redraw table
                filter1:$('#filter1').val(),
                filter2:$('#filter2').val(),
                filter3:$('#filter3').val(),
                ...
              }
            },
          } );
        }
      } );
      
      [problem] branch `else` will be executed only 1 time at very first initialization of table, 
      and branch `if` is executed from then on using draw() to renew table, unfortunately draw() is unable to catch the refreshed filters
      [reason] filters are outside of dataTable and not catched while changed
      
    (3) recreate a new dataTable everytime filters is changed & triggered
      var dataTable;
      $('#filterButton').on( 'click', function() {
        dataTable = $('#example').dataTable( {
          "destroy": true,    //notice here
          ...
          "ajax": {
            "url": "...",
            "type": "GET",
            "cache": false,
            "data": {         //refresh fiters while redraw table
              filter1:$('#filter1').val(),
              filter2:$('#filter2').val(),
              filter3:$('#filter3').val(),
              ...
            }
          },
        } );
      } );
      
      Problem resolved!!
      
      [reason]
        <1> DataTables provides a destroy() method to destroy an old table, so you would be able to initialise a new one in its place.
          For example:
          table = $('#example').DataTable( {
            paging: false
          } );
          table.destroy();
          table = $('#example').DataTable( {
            searching: false
          } );
          Note that paging will be enabled in the second initialisation here as it is a completely new DataTable,
          and paging is not explicitly disabled!
          
        <2> As a short-cut, like the `retrieve` option, there is also a `destroy` option that can be used to DataTables to destroy the existing table. 
        <3> if it is essential for you to be able to dynamically enable and disable features, the destroy option can be used, 
        noting the performance impact that this will have.
  > [references]
    (1) dataTable.draw()
        https://datatables.net/reference/api/draw()
    (2) dataTable.destroy()
        http://datatables.net/manual/tech-notes/3
  
5.initialize the font color of the initial value of input using CSS
    <style>
        input[type="text"] {color:grey}
        input[type="text"]:focus {color:black}
    </style>

6.change sAjaxSource of dataTable dynamicly
  > oTable.fnSettings().sAjaxSource='{your new url}';
  > oTable.fnDraw();

7.usage of bootstrap tooltip
  reference: http://stackoverflow.com/questions/20545745/bootstrap-tooltip-not-showing-up
             http://stackoverflow.com/questions/9958825/how-do-i-bind-twitter-bootstrap-tooltips-to-dynamically-created-elements
  [1] add attributes to element
  data-toggle='tooltip' data-placement='bottom' title='...'
  for example:
  <button data-toggle='tooltip' data-placement='bottom' title='...' onclick='...'>...</button>
  [2] enable and initialize tooltip
  $(document).ready(function(){
      ...
      // enable tooltip
      $(function(){
          $('body').tooltip({ selector: '[data-toggle="tooltip"]' });
      });
  });
  
